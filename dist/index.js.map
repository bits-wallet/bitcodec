{"version":3,"file":"index.js","mappings":"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","sources":["webpack://[name]/./node_modules/@bitmatrix/int53/common.js","webpack://[name]/./node_modules/@bitmatrix/int53/index.js","webpack://[name]/./node_modules/@bitmatrix/int53/read.js","webpack://[name]/./node_modules/@bitmatrix/int53/write.js","webpack://[name]/./src/lib/CAllBuffer.ts","webpack://[name]/./src/lib/CArray.ts","webpack://[name]/./src/lib/CBuffer.ts","webpack://[name]/./src/lib/CNumber.ts","webpack://[name]/./src/lib/CObject.ts","webpack://[name]/./src/lib/CString.ts","webpack://[name]/./src/lib/CVarArray.ts","webpack://[name]/./src/lib/CVarBuffer.ts","webpack://[name]/./src/lib/CVarString.ts","webpack://[name]/./src/lib/CVarUIntBitcoin.ts","webpack://[name]/./src/models/NumberTypes.ts","webpack://[name]/./src/util.ts","webpack://[name]/webpack/bootstrap","webpack://[name]/./src/index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toDouble = exports.intHighLow = exports.uintHighLow = exports.onesComplement = exports.assert = exports.Int53Type = void 0;\nconst MAX_UINT32 = 0x00000000ffffffff;\nconst MAX_INT53 = 0x001fffffffffffff;\nvar Int53Type;\n(function (Int53Type) {\n    Int53Type[\"Int64BE\"] = \"Int64BE\";\n    Int53Type[\"Int64LE\"] = \"Int64LE\";\n    Int53Type[\"UInt64BE\"] = \"UInt64BE\";\n    Int53Type[\"UInt64LE\"] = \"UInt64LE\";\n})(Int53Type = exports.Int53Type || (exports.Int53Type = {}));\nconst assert = (test, message) => {\n    if (!test)\n        throw new Error(message);\n};\nexports.assert = assert;\nconst onesComplement = (number) => {\n    number = ~number;\n    if (number < 0) {\n        number = (number & 0x7fffffff) + 0x80000000;\n    }\n    return number;\n};\nexports.onesComplement = onesComplement;\nconst uintHighLow = (number) => {\n    (0, exports.assert)(number > -1 && number <= MAX_INT53, \"number out of range\");\n    (0, exports.assert)(Math.floor(number) === number, \"number must be an integer\");\n    var high = 0;\n    var signbit = number & 0xffffffff;\n    var low = signbit < 0 ? (number & 0x7fffffff) + 0x80000000 : signbit;\n    if (number > MAX_UINT32) {\n        high = (number - low) / (MAX_UINT32 + 1);\n    }\n    return [high, low];\n};\nexports.uintHighLow = uintHighLow;\nconst intHighLow = (number) => {\n    if (number > -1) {\n        return (0, exports.uintHighLow)(number);\n    }\n    var hl = (0, exports.uintHighLow)(-number);\n    var high = (0, exports.onesComplement)(hl[0]);\n    var low = (0, exports.onesComplement)(hl[1]);\n    if (low === MAX_UINT32) {\n        high += 1;\n        low = 0;\n    }\n    else {\n        low += 1;\n    }\n    return [high, low];\n};\nexports.intHighLow = intHighLow;\nconst toDouble = (high, low, signed) => {\n    if (signed && (high & 0x80000000) !== 0) {\n        high = (0, exports.onesComplement)(high);\n        low = (0, exports.onesComplement)(low);\n        (0, exports.assert)(high < 0x00200000, \"number too small\");\n        return -(high * (MAX_UINT32 + 1) + low + 1);\n    }\n    else {\n        //positive\n        (0, exports.assert)(high < 0x00200000, \"number too large\");\n        return high * (MAX_UINT32 + 1) + low;\n    }\n};\nexports.toDouble = toDouble;\n//# sourceMappingURL=common.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readInt53 = exports.writeInt53 = exports.Int53Type = void 0;\nvar common_1 = require(\"./common\");\nObject.defineProperty(exports, \"Int53Type\", { enumerable: true, get: function () { return common_1.Int53Type; } });\nvar write_1 = require(\"./write\");\nObject.defineProperty(exports, \"writeInt53\", { enumerable: true, get: function () { return write_1.write; } });\nvar read_1 = require(\"./read\");\nObject.defineProperty(exports, \"readInt53\", { enumerable: true, get: function () { return read_1.read; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.read = void 0;\nconst common_1 = require(\"./common\");\nconst read = (int53Type, buffer, offset = 0) => {\n    const BE = int53Type.endsWith(\"BE\");\n    const [high, low] = BE ? [buffer.readUInt32BE(offset), buffer.readUInt32BE(offset + 4)] : [buffer.readUInt32LE(offset + 4), buffer.readUInt32LE(offset)];\n    const signed = int53Type.startsWith(\"Int\");\n    return (0, common_1.toDouble)(high, low, signed);\n};\nexports.read = read;\n//# sourceMappingURL=read.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.write = void 0;\nconst common_1 = require(\"./common\");\nconst write = (int53Type, number, buffer, offset = 0) => {\n    const signed = int53Type.startsWith(\"Int\");\n    const hl = signed ? (0, common_1.intHighLow)(number) : (0, common_1.uintHighLow)(number);\n    const BE = int53Type.endsWith(\"BE\");\n    if (BE) {\n        buffer.writeUInt32BE(hl[0], offset);\n        buffer.writeUInt32BE(hl[1], offset + 4);\n    }\n    else {\n        buffer.writeUInt32LE(hl[1], offset);\n        buffer.writeUInt32LE(hl[0], offset + 4);\n    }\n};\nexports.write = write;\n//# sourceMappingURL=write.js.map","import { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CAllBuffer implements IBitcodec<Buffer> {\n  private length: number;\n  encodingLength = (): number => this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor() {\n    this.length = 0;\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n  }\n\n  encode = (value: Buffer, buffer?: Buffer, offset = 0): Buffer => {\n    if (!Buffer.isBuffer(value)) throw new TypeError(\"value must be a Buffer instance\"); // for CArray encode iter\n    this.length = value.length - offset;\n    if (!buffer) return Buffer.from(value);\n    if (offset + this.length > buffer.length) throw new RangeError(\"destination buffer is too small\");\n    value.copy(buffer, offset);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): Buffer => {\n    if (!end) end = buffer.length;\n    this.length = buffer.length - offset;\n    if (offset + this.length > end) throw new RangeError(\"not enough data for decode\");\n    return Buffer.from(buffer.slice(offset, offset + this.length));\n  };\n}\n","import * as util from \"../util\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CBuffer } from \"./CBuffer\";\n\nexport class CArray implements IBitcodec<any[]> {\n  private length: number;\n  private anyCodec: IBitcodec<any>;\n\n  private calcLength = (items: any[]) => {\n    return util.size(items, this.anyCodec.encodingLength);\n  };\n\n  encodingLength = (array?: any[]): number => {\n    if (array === undefined) throw new TypeError(\"value must be an Array instance\");\n    if (array.length !== this.length) throw new RangeError(\"value.length is out of bounds\");\n    return this.calcLength(array);\n  };\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(length: number, anyCodec: IBitcodec<any>) {\n    this.length = length;\n    this.anyCodec = anyCodec;\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n  }\n\n  encode = (value: any[], buffer?: Buffer, offset = 0): Buffer => {\n    if (value.length !== this.length) throw new RangeError(\"value.length is out of bounds\");\n    if (!buffer) buffer = Buffer.allocUnsafe(this.calcLength(value));\n\n    const typeEncode = this.anyCodec.encode;\n    const typeEncodeBytes = this.anyCodec.encodeBytes;\n\n    /* this.encodeBytes =\n      value.reduce((previusValue, currentItem, _) => {\n        this.anyCodec.encode(currentItem, buffer, previusValue);\n        const newAnyCodecEncodeBytes = this.anyCodec.encodeBytes;\n        return previusValue + newAnyCodecEncodeBytes;\n      }, offset) - offset; */\n\n    this.encodeBytes =\n      util.size(\n        value,\n        function (item, index, loffset) {\n          typeEncode(item, buffer, loffset);\n          return typeEncodeBytes;\n        },\n        offset\n      ) - offset;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): any[] => {\n    if (!offset) offset = 0;\n    const items = new Array(this.length);\n\n    const typeDecode = this.anyCodec.decode;\n    const typeDecodeBytes = this.anyCodec.decodeBytes;\n\n    /* this.decodeBytes =\n      items.reduce((previusValue, currentItem, currentIndex) => {\n        items[currentIndex] = this.anyCodec.decode(buffer, previusValue, end);\n        const newAnyCodecDecodeBytes = this.anyCodec.decodeBytes;\n        return previusValue + newAnyCodecDecodeBytes;\n      }, offset + offset) - offset; */\n\n    this.decodeBytes =\n      util.size(\n        items,\n        function (item, index, loffset) {\n          items[index || 0] = typeDecode(buffer, loffset, end);\n          return typeDecodeBytes;\n        },\n        offset\n      ) - offset;\n    return items;\n  };\n}\n","import { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CBuffer implements IBitcodec<Buffer> {\n  private length: number;\n  encodingLength = (): number => this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(length: number) {\n    this.length = length;\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n  }\n\n  encode = (value: Buffer, buffer?: Buffer, offset = 0): Buffer => {\n    if (!Buffer.isBuffer(value)) throw new TypeError(\"value must be a Buffer instance\"); // for CArray encode iter\n    if (value.length !== this.length) throw new RangeError(\"value.length is out of bounds\");\n    if (!buffer) return Buffer.from(value);\n    if (offset + this.length > buffer.length) throw new RangeError(\"destination buffer is too small\");\n    value.copy(buffer, offset);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): Buffer => {\n    if (!end) end = buffer.length;\n    if (offset + this.length > end) throw new RangeError(\"not enough data for decode\");\n    return Buffer.from(buffer.slice(offset, offset + this.length));\n  };\n}\n","import { Int53Type, readInt53, writeInt53 } from \"@bitmatrix/int53\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { NumberTypes } from \"../models/NumberTypes\";\n\nexport class CNumber implements IBitcodec<number> {\n  private length: number;\n  private write: (buffer: Buffer, value: number, offset?: number) => void;\n  private read: (buffer: Buffer, offset?: number | undefined) => number;\n\n  encodingLength = (): number => this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(numberType: NumberTypes, length: number) {\n    this.length = length;\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n\n    if (Buffer.prototype[\"write\" + numberType]) {\n      this.write = (buffer: Buffer, value: number, offset?: number) => {\n        return (buffer as any)[\"write\" + numberType](value, offset);\n      };\n    } else {\n      this.write = (buffer: Buffer, value: number, offset?: number) => {\n        return writeInt53(numberType as unknown as Int53Type, value, buffer, offset);\n      };\n    }\n\n    if (Buffer.prototype[\"read\" + numberType]) {\n      this.read = (buffer: Buffer, offset?: number) => {\n        return (buffer as any)[\"read\" + numberType](offset);\n      };\n    } else {\n      this.read = (buffer: Buffer, offset?: number) => {\n        return readInt53(numberType as unknown as Int53Type, buffer, offset);\n      };\n    }\n  }\n\n  encode = (value: number, buffer?: Buffer, offset = 0): Buffer => {\n    buffer = buffer || Buffer.allocUnsafe(this.length);\n\n    this.write(buffer, value, offset);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): number => {\n    if (!end) return this.read(buffer, offset);\n    return this.read(buffer.slice(offset, end), 0);\n  };\n}\n","import { BitcodecItem } from \"../models/BitcodecItem\";\nimport { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CObject implements IBitcodec<object> {\n  private items: { name: string; type: IBitcodec<any> }[];\n\n  encodeBytes: number;\n  decodeBytes: number;\n  encodingLength: (t?: object) => number;\n\n  constructor(items: BitcodecItem[]) {\n    this.items = items.map((item: BitcodecItem) => (Array.isArray(item) ? { name: item[0], type: item[1] } : item));\n\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n\n    this.encodingLength = (o?: object): number => {\n      if (o === undefined) throw new TypeError(\"Expected Object, got \" + o);\n      return this.items.reduce((previousValue: number, currentValue: { name: string; type: IBitcodec<any> }) => {\n        const value = (o as any)[currentValue.name];\n        return previousValue + currentValue.type.encodingLength(value);\n      }, 0);\n    };\n  }\n\n  encode = (object: object, buffer?: Buffer, offset = 0): Buffer => {\n    const bytes = this.encodingLength(object);\n    if (buffer === undefined) buffer = Buffer.allocUnsafe(bytes);\n    else if (buffer.length - offset < bytes) throw new RangeError(\"destination buffer is too small\");\n\n    this.items.forEach((item) => {\n      const value = (object as any)[item.name];\n      item.type.encode(value, buffer, offset);\n      offset += item.type.encodeBytes;\n    });\n    this.encodeBytes = bytes;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset: number = 0, end?: number | undefined): object => {\n    let result = {};\n    const start = offset;\n\n    this.items.forEach((item) => {\n      const value = item.type.decode(buffer, offset, end);\n      offset += item.type.decodeBytes;\n      (result as any)[item.name] = value;\n    });\n    this.decodeBytes = offset - start;\n\n    return result;\n  };\n}\n","import { EncodingType } from \"../models/EncodingType\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CBuffer } from \"./CBuffer\";\n\nexport class CString implements IBitcodec<string> {\n  private length: number;\n  private bufferCodec: IBitcodec<Buffer>;\n  private encodingType: EncodingType;\n\n  encodingLength: (value?: string) => number;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(length: number, encodingType: EncodingType = \"utf8\") {\n    this.length = length;\n    this.encodingType = encodingType;\n    this.bufferCodec = new CBuffer(this.length);\n\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n\n    this.encodingLength = (value?: string) => this.length;\n  }\n\n  encode = (value: string, buffer?: Buffer, offset = 0): Buffer => {\n    if (Buffer.byteLength(value, this.encodingType) !== this.length) throw new RangeError(\"value.length is out of bounds\");\n    if (!buffer) return Buffer.from(value, this.encodingType);\n    if (offset + this.length > buffer.length) throw new RangeError(\"destination buffer is too small\");\n\n    buffer.write(value, offset, length, this.encodingType);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): string => this.bufferCodec.decode(buffer, offset, end).toString(this.encodingType);\n}\n","import * as util from \"../util\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CBuffer } from \"./CBuffer\";\n\nexport class CVarArray implements IBitcodec<any[]> {\n  private length: number = -1;\n  private lengthType: IBitcodec<any>;\n  private anyCodec: IBitcodec<any>;\n\n  private calcLength = (items: any[]) => {\n    return util.size(items, this.anyCodec.encodingLength, this.lengthType.encodingLength(items.length));\n  };\n\n  encodingLength = (array?: any[]): number => {\n    if (array === undefined) throw new TypeError(\"value must be an Array instance\");\n    return this.calcLength(array);\n  };\n\n  encodeBytes: number = -1;\n  decodeBytes: number = -1;\n\n  constructor(lengthType: IBitcodec<any>, anyCodec: IBitcodec<any>) {\n    this.lengthType = lengthType;\n    this.anyCodec = anyCodec;\n  }\n\n  encode = (value: any[], buffer?: Buffer, offset = 0): Buffer => {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.calcLength(value));\n\n    this.lengthType.encode(value.length, buffer, offset);\n\n    /* this.encodeBytes =\n      value.reduce((previusValue, currentItem, _) => {\n        this.anyCodec.encode(currentItem, buffer, previusValue);\n        const newAnyCodecEncodeBytes = this.anyCodec.encodeBytes;\n        return previusValue + newAnyCodecEncodeBytes;\n      }, this.lengthType.encodeBytes + offset) - offset; */\n\n    this.encodeBytes =\n      util.size(\n        value,\n        (item, index, loffset) => {\n          this.anyCodec.encode(item, buffer, loffset);\n          return this.anyCodec.encodeBytes;\n        },\n        this.lengthType.encodeBytes + offset\n      ) - offset;\n\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): any[] => {\n    if (!offset) offset = 0;\n    const items = new Array(this.lengthType.decode(buffer, offset, end));\n\n    /* this.decodeBytes =\n      items.reduce((previusValue, currentItem, currentIndex) => {\n        items[currentIndex] = this.anyCodec.decode(buffer, previusValue, end);\n        const newAnyCodecDecodeBytes = this.anyCodec.decodeBytes;\n        return previusValue + newAnyCodecDecodeBytes;\n      }, this.lengthType.decodeBytes + offset) - offset; */\n\n    this.decodeBytes =\n      util.size(\n        items,\n        (item, index, loffset) => {\n          items[index || 0] = this.anyCodec.decode(buffer, loffset, end);\n          return this.anyCodec.decodeBytes;\n        },\n        this.lengthType.decodeBytes + offset\n      ) - offset;\n    return items;\n  };\n}\n","import { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CVarBuffer implements IBitcodec<any> {\n  private anyCodec: IBitcodec<any>;\n  encodingLength: (buffer?: Buffer) => number;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(anyCodec: IBitcodec<any>) {\n    this.anyCodec = anyCodec;\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n\n    this.encodingLength = (buffer?: Buffer) => {\n      if (buffer === undefined) throw new TypeError(\"value must be a Buffer instance\"); // for CArray encode iter\n      return this.anyCodec.encodingLength(buffer.length) + buffer.length;\n    };\n  }\n\n  encode = (value: Buffer, buffer?: Buffer, offset = 0): Buffer => {\n    const bytes = this.encodingLength(value);\n    if (!buffer) buffer = Buffer.allocUnsafe(bytes);\n    else if (buffer.length - offset < bytes) throw new RangeError(\"destination buffer is too small\");\n\n    this.anyCodec.encode(value.length, buffer, offset);\n    offset += this.anyCodec.encodeBytes;\n\n    value.copy(buffer, offset);\n    this.encodeBytes = bytes;\n\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): Buffer => {\n    if (end === undefined) end = buffer.length;\n    const start = offset;\n\n    const length = this.anyCodec.decode(buffer, offset, end);\n    offset += this.anyCodec.decodeBytes;\n\n    if (offset + length > end) throw new RangeError(\"not enough data for decode\");\n\n    this.decodeBytes = offset + length - start;\n    return Buffer.from(buffer.slice(offset, offset + length));\n  };\n}\n","import { EncodingType } from \"../models/EncodingType\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CVarBuffer } from \"./CVarBuffer\";\n\nexport class CVarString implements IBitcodec<string> {\n  private anyCodec: IBitcodec<any>;\n  private encodingType: EncodingType;\n  private varBufferCodec: CVarBuffer;\n  encodingLength: (value?: string) => number;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(anyCodec: IBitcodec<any>, encodingType: EncodingType = \"utf8\") {\n    this.anyCodec = anyCodec;\n    this.encodingType = encodingType;\n    this.varBufferCodec = new CVarBuffer(anyCodec);\n\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n\n    this.encodingLength = (value?: string) => {\n      if (value === undefined) throw new TypeError(\"value must be a string\");\n      const valueLength = Buffer.byteLength(value, this.encodingType);\n      return this.anyCodec.encodingLength(value.length) + valueLength;\n    };\n  }\n\n  encode = (value: string, buffer?: Buffer, offset = 0): Buffer => {\n    const valueLength = Buffer.byteLength(value, this.encodingType);\n    const bytes = this.anyCodec.encodingLength(value.length) + valueLength;\n\n    if (!buffer) buffer = Buffer.allocUnsafe(bytes);\n    if (offset + bytes > buffer.length) throw new RangeError(\"destination buffer is too small\");\n\n    this.anyCodec.encode(valueLength, buffer, offset);\n    offset += this.anyCodec.encodeBytes;\n    buffer.write(value, offset, valueLength, this.encodingType);\n\n    this.encodeBytes = bytes;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): string => {\n    const str = this.varBufferCodec.decode(buffer, offset, end).toString(this.encodingType);\n    this.decodeBytes = this.varBufferCodec.decodeBytes;\n    return str;\n  };\n}\n","import { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CVarUIntBitcoin implements IBitcodec<number> {\n  private MAX_SAFE_INTEGER: number = 9007199254740991;\n\n  private checkUInt53 = (n: number) => {\n    if (n < 0 || n > this.MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError(\"value out of range\");\n  };\n\n  encodeBytes: number;\n  decodeBytes: number;\n  encodingLength: (t?: number | undefined) => number;\n\n  constructor() {\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n    this.encodingLength = (number?: number) => {\n      if (number === undefined) throw new TypeError(\"Expected number, got undefined\");\n      this.checkUInt53(number);\n      return number < 0xfd ? 1 : number <= 0xffff ? 3 : number <= 0xffffffff ? 5 : 9;\n    };\n  }\n\n  encode = (value: number, buffer?: Buffer, offset: number = 0): Buffer => {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.encodingLength(value));\n\n    // 8 bit\n    if (value < 0xfd) {\n      buffer.writeUInt8(value, offset);\n      this.encodeBytes = 1;\n\n      // 16 bit\n    } else if (value <= 0xffff) {\n      buffer.writeUInt8(0xfd, offset);\n      buffer.writeUInt16LE(value, offset + 1);\n      this.encodeBytes = 3;\n\n      // 32 bit\n    } else if (value <= 0xffffffff) {\n      buffer.writeUInt8(0xfe, offset);\n      buffer.writeUInt32LE(value, offset + 1);\n      this.encodeBytes = 5;\n\n      // 64 bit\n    } else {\n      buffer.writeUInt8(0xff, offset);\n      buffer.writeUInt32LE(value >>> 0, offset + 1);\n      buffer.writeUInt32LE((value / 0x100000000) | 0, offset + 5);\n      this.encodeBytes = 9;\n    }\n\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset: number = 0, end?: number): number => {\n    const first = buffer.readUInt8(offset);\n\n    // 8 bit\n    if (first < 0xfd) {\n      this.decodeBytes = 1;\n      return first;\n\n      // 16 bit\n    } else if (first === 0xfd) {\n      this.decodeBytes = 3;\n      return buffer.readUInt16LE(offset + 1);\n\n      // 32 bit\n    } else if (first === 0xfe) {\n      this.decodeBytes = 5;\n      return buffer.readUInt32LE(offset + 1);\n\n      // 64 bit\n    } else {\n      this.decodeBytes = 9;\n      var lo = buffer.readUInt32LE(offset + 1);\n      var hi = buffer.readUInt32LE(offset + 5);\n      var number = hi * 0x0100000000 + lo;\n      this.checkUInt53(number);\n\n      return number;\n    }\n  };\n}\n","export enum NumberTypes {\n  Byte = \"UInt8\",\n  Int8 = \"Int8\",\n  UInt8 = \"UInt8\",\n  Int16BE = \"Int16BE\",\n  Int16LE = \"Int16LE\",\n  UInt16BE = \"UInt16BE\",\n  UInt16LE = \"UInt16LE\",\n  Int32BE = \"Int32BE\",\n  Int32LE = \"Int32LE\",\n  UInt32BE = \"UInt32BE\",\n  UInt32LE = \"UInt32LE\",\n  Int64BE = \"Int64BE\",\n  Int64LE = \"Int64LE\",\n  UInt64BE = \"UInt64BE\",\n  UInt64LE = \"UInt64LE\",\n  FloatBE = \"FloatBE\",\n  FloatLE = \"FloatLE\",\n  DoubleBE = \"DoubleBE\",\n  DoubleLE = \"DoubleLE\",\n}\n","export const size = <T>(items: T[], iter: (item?: T, index?: number, ac?: number) => number, acc: number = 0) => {\n  let result = acc;\n  for (let i = 0; i < items.length; i++) result += iter(items[i], i, result);\n  return result;\n\n  /* return items.reduce((previusValue, currentItem, currentIndex) => {\n    return previusValue + iter(items[currentIndex], currentIndex, previusValue);\n  }, acc); */\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { IBitcodec } from \"./models/IBitcodec\";\nimport { BitcodecItem } from \"./models/BitcodecItem\";\nimport { EncodingType } from \"./models/EncodingType\";\nimport { NumberTypes } from \"./models/NumberTypes\";\n\nimport { CAllBuffer } from \"./lib/CAllBuffer\";\nimport { CArray } from \"./lib/CArray\";\nimport { CBuffer } from \"./lib/CBuffer\";\nimport { CNumber } from \"./lib/CNumber\";\nimport { CObject } from \"./lib/CObject\";\nimport { CString } from \"./lib/CString\";\nimport { CVarArray } from \"./lib/CVarArray\";\nimport { CVarBuffer } from \"./lib/CVarBuffer\";\nimport { CVarString } from \"./lib/CVarString\";\nimport { CVarUIntBitcoin } from \"./lib/CVarUIntBitcoin\";\n\nexport default {\n  AllBuffer: new CAllBuffer(),\n  Array: (length: number, anyCodec: IBitcodec<any>) => new CArray(length, anyCodec),\n  Buffer: (length: number) => new CBuffer(length),\n  Byte: new CNumber(NumberTypes.UInt8, 1),\n  Number: {\n    Int8: new CNumber(NumberTypes.Int8, 1),\n    UInt8: new CNumber(NumberTypes.UInt8, 1),\n    Int16BE: new CNumber(NumberTypes.Int16BE, 2),\n    Int16LE: new CNumber(NumberTypes.Int16LE, 2),\n    UInt16BE: new CNumber(NumberTypes.UInt16BE, 2),\n    UInt16LE: new CNumber(NumberTypes.UInt16LE, 2),\n    Int32BE: new CNumber(NumberTypes.Int32BE, 4),\n    Int32LE: new CNumber(NumberTypes.Int32LE, 4),\n    UInt32BE: new CNumber(NumberTypes.UInt32BE, 4),\n    UInt32LE: new CNumber(NumberTypes.UInt32LE, 4),\n    Int64BE: new CNumber(NumberTypes.Int64BE, 8),\n    Int64LE: new CNumber(NumberTypes.Int64LE, 8),\n    UInt64BE: new CNumber(NumberTypes.UInt64BE, 8),\n    UInt64LE: new CNumber(NumberTypes.UInt64LE, 8),\n    FloatBE: new CNumber(NumberTypes.FloatBE, 4),\n    FloatLE: new CNumber(NumberTypes.FloatLE, 4),\n    DoubleBE: new CNumber(NumberTypes.DoubleBE, 8),\n    DoubleLE: new CNumber(NumberTypes.DoubleLE, 8),\n  },\n  Object: (items: BitcodecItem[]) => new CObject(items),\n  String: (length: number, encodingType: EncodingType = \"utf8\") => new CString(length, encodingType),\n  VarArray: (lengthType: IBitcodec<any>, anyCodec: IBitcodec<any>) => new CVarArray(lengthType, anyCodec),\n  VarBuffer: (anyCodec: IBitcodec<any>) => new CVarBuffer(anyCodec),\n  VarString: (anyCodec: IBitcodec<any>, encodingType: EncodingType = \"utf8\") => new CVarString(anyCodec, encodingType),\n  VarUIntBitcoin: new CVarUIntBitcoin(),\n};\n"],"names":["Object","defineProperty","exports","value","toDouble","intHighLow","uintHighLow","onesComplement","assert","Int53Type","MAX_UINT32","test","message","Error","number","Math","floor","high","signbit","low","hl","signed","readInt53","writeInt53","common_1","enumerable","get","write_1","write","read_1","read","int53Type","buffer","offset","BE","endsWith","readUInt32BE","readUInt32LE","startsWith","writeUInt32BE","writeUInt32LE","length","encodingLength","this","encodeBytes","decodeBytes","constructor","encode","Buffer","isBuffer","TypeError","from","RangeError","copy","decode","end","slice","anyCodec","calcLength","items","util","size","array","undefined","allocUnsafe","typeEncode","typeEncodeBytes","item","index","loffset","Array","typeDecode","typeDecodeBytes","numberType","prototype","map","isArray","name","type","o","reduce","previousValue","currentValue","object","bytes","forEach","result","start","bufferCodec","encodingType","CBuffer","byteLength","toString","lengthType","varBufferCodec","CVarBuffer","valueLength","str","MAX_SAFE_INTEGER","checkUInt53","n","writeUInt8","writeUInt16LE","first","readUInt8","readUInt16LE","lo","NumberTypes","iter","acc","i","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","call","AllBuffer","CAllBuffer","CArray","Byte","CNumber","UInt8","Number","Int8","Int16BE","Int16LE","UInt16BE","UInt16LE","Int32BE","Int32LE","UInt32BE","UInt32LE","Int64BE","Int64LE","UInt64BE","UInt64LE","FloatBE","FloatLE","DoubleBE","DoubleLE","CObject","String","CString","VarArray","CVarArray","VarBuffer","VarString","CVarString","VarUIntBitcoin","CVarUIntBitcoin"],"sourceRoot":""}