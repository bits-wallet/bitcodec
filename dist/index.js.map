{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@bitmatrix/bitcodec/./node_modules/@bitmatrix/int53/common.js","webpack://@bitmatrix/bitcodec/./node_modules/@bitmatrix/int53/index.js","webpack://@bitmatrix/bitcodec/./node_modules/@bitmatrix/int53/read.js","webpack://@bitmatrix/bitcodec/./node_modules/@bitmatrix/int53/write.js","webpack://@bitmatrix/bitcodec/./src/errors.ts","webpack://@bitmatrix/bitcodec/./src/lib/CAllBuffer.ts","webpack://@bitmatrix/bitcodec/./src/lib/CArray.ts","webpack://@bitmatrix/bitcodec/./src/lib/CBuffer.ts","webpack://@bitmatrix/bitcodec/./src/lib/CNumber.ts","webpack://@bitmatrix/bitcodec/./src/lib/CObject.ts","webpack://@bitmatrix/bitcodec/./src/lib/CString.ts","webpack://@bitmatrix/bitcodec/./src/lib/CVarArray.ts","webpack://@bitmatrix/bitcodec/./src/lib/CVarBuffer.ts","webpack://@bitmatrix/bitcodec/./src/lib/CVarString.ts","webpack://@bitmatrix/bitcodec/./src/lib/CVarUIntBitcoin.ts","webpack://@bitmatrix/bitcodec/./src/lib/index.ts","webpack://@bitmatrix/bitcodec/./src/models/NumberTypes.ts","webpack://@bitmatrix/bitcodec/./src/models/index.ts","webpack://@bitmatrix/bitcodec/./src/util.ts","webpack://@bitmatrix/bitcodec/webpack/bootstrap","webpack://@bitmatrix/bitcodec/./src/index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toDouble = exports.intHighLow = exports.uintHighLow = exports.onesComplement = exports.assert = exports.Int53Type = void 0;\nconst MAX_UINT32 = 0x00000000ffffffff;\nconst MAX_INT53 = 0x001fffffffffffff;\nvar Int53Type;\n(function (Int53Type) {\n    Int53Type[\"Int64BE\"] = \"Int64BE\";\n    Int53Type[\"Int64LE\"] = \"Int64LE\";\n    Int53Type[\"UInt64BE\"] = \"UInt64BE\";\n    Int53Type[\"UInt64LE\"] = \"UInt64LE\";\n})(Int53Type = exports.Int53Type || (exports.Int53Type = {}));\nconst assert = (test, message) => {\n    if (!test)\n        throw new Error(message);\n};\nexports.assert = assert;\nconst onesComplement = (number) => {\n    number = ~number;\n    if (number < 0) {\n        number = (number & 0x7fffffff) + 0x80000000;\n    }\n    return number;\n};\nexports.onesComplement = onesComplement;\nconst uintHighLow = (number) => {\n    (0, exports.assert)(number > -1 && number <= MAX_INT53, \"number out of range\");\n    (0, exports.assert)(Math.floor(number) === number, \"number must be an integer\");\n    var high = 0;\n    var signbit = number & 0xffffffff;\n    var low = signbit < 0 ? (number & 0x7fffffff) + 0x80000000 : signbit;\n    if (number > MAX_UINT32) {\n        high = (number - low) / (MAX_UINT32 + 1);\n    }\n    return [high, low];\n};\nexports.uintHighLow = uintHighLow;\nconst intHighLow = (number) => {\n    if (number > -1) {\n        return (0, exports.uintHighLow)(number);\n    }\n    var hl = (0, exports.uintHighLow)(-number);\n    var high = (0, exports.onesComplement)(hl[0]);\n    var low = (0, exports.onesComplement)(hl[1]);\n    if (low === MAX_UINT32) {\n        high += 1;\n        low = 0;\n    }\n    else {\n        low += 1;\n    }\n    return [high, low];\n};\nexports.intHighLow = intHighLow;\nconst toDouble = (high, low, signed) => {\n    if (signed && (high & 0x80000000) !== 0) {\n        high = (0, exports.onesComplement)(high);\n        low = (0, exports.onesComplement)(low);\n        (0, exports.assert)(high < 0x00200000, \"number too small\");\n        return -(high * (MAX_UINT32 + 1) + low + 1);\n    }\n    else {\n        //positive\n        (0, exports.assert)(high < 0x00200000, \"number too large\");\n        return high * (MAX_UINT32 + 1) + low;\n    }\n};\nexports.toDouble = toDouble;\n//# sourceMappingURL=common.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readInt53 = exports.writeInt53 = exports.Int53Type = void 0;\nvar common_1 = require(\"./common\");\nObject.defineProperty(exports, \"Int53Type\", { enumerable: true, get: function () { return common_1.Int53Type; } });\nvar write_1 = require(\"./write\");\nObject.defineProperty(exports, \"writeInt53\", { enumerable: true, get: function () { return write_1.write; } });\nvar read_1 = require(\"./read\");\nObject.defineProperty(exports, \"readInt53\", { enumerable: true, get: function () { return read_1.read; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.read = void 0;\nconst common_1 = require(\"./common\");\nconst read = (int53Type, buffer, offset = 0) => {\n    const BE = int53Type.endsWith(\"BE\");\n    const [high, low] = BE ? [buffer.readUInt32BE(offset), buffer.readUInt32BE(offset + 4)] : [buffer.readUInt32LE(offset + 4), buffer.readUInt32LE(offset)];\n    const signed = int53Type.startsWith(\"Int\");\n    return (0, common_1.toDouble)(high, low, signed);\n};\nexports.read = read;\n//# sourceMappingURL=read.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.write = void 0;\nconst common_1 = require(\"./common\");\nconst write = (int53Type, number, buffer, offset = 0) => {\n    const signed = int53Type.startsWith(\"Int\");\n    const hl = signed ? (0, common_1.intHighLow)(number) : (0, common_1.uintHighLow)(number);\n    const BE = int53Type.endsWith(\"BE\");\n    if (BE) {\n        buffer.writeUInt32BE(hl[0], offset);\n        buffer.writeUInt32BE(hl[1], offset + 4);\n    }\n    else {\n        buffer.writeUInt32LE(hl[1], offset);\n        buffer.writeUInt32LE(hl[0], offset + 4);\n    }\n};\nexports.write = write;\n//# sourceMappingURL=write.js.map","export const checkLength = (codecName: string, valueLength: number, codecLength: number) => {\n  if (valueLength !== codecLength) throw new RangeError(`${codecName} Codec: value length is not equal codec length. valueLength = ${valueLength}, codecLength = ${codecLength}.`);\n};\n\nexport const checkBufferLengthForEncode = (codecName: string, buffer: Buffer, offset: number, codecLength: number) => {\n  if (buffer.length - offset < codecLength)\n    throw new RangeError(`${codecName} Codec: buffer is too small. buffer.length = ${buffer.length}, offset = ${offset}, codecLength = ${codecLength}.`);\n};\n\nexport const checkBufferLengthForDecode = (codecName: string, offset: number, end: number, codecLength: number) => {\n  if (end - offset < codecLength) throw new RangeError(`${codecName} Codec: not enough data for decode. offset = ${offset}, end = ${end}, codecLength = ${codecLength}.`);\n};\n\nexport const checkDefined = (codecName: string, value?: any, type: \"object\" | \"array\" | \"buffer\" | \"number\" | \"string\" = \"object\") => {\n  if (value === undefined) throw new TypeError(`${codecName} Codec: value must be ${type} but got undefined.`);\n  if (type === \"buffer\" && !Buffer.isBuffer(value)) throw new TypeError(`${codecName} Codec: value must be ${type} but got undefined.`);\n};\n\nexport const typeError = (codecName: string, message: string) => {\n  throw new TypeError(`${codecName} Codec: ${message}.`);\n};\n\nexport const rangeError = (codecName: string, message: string) => {\n  throw new RangeError(`${codecName} Codec: ${message}.`);\n};\n","import { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CAllBuffer implements IBitcodec<Buffer> {\n  private length: number;\n  encodingLength = (buffer?: Buffer): number => buffer?.length || this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor() {\n    this.length = 0;\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n  }\n\n  encode = (value: Buffer, buffer?: Buffer, offset = 0): Buffer => {\n    this.length = value.length;\n    this.encodeBytes = value.length;\n    this.decodeBytes = value.length;\n    if (!Buffer.isBuffer(value)) throw new TypeError(\"value must be a Buffer instance\"); // for CArray encode iter\n    if (!buffer) return Buffer.from(value);\n    if (offset + this.length > buffer.length) throw new RangeError(\"destination buffer is too small\");\n    value.copy(buffer, offset);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): Buffer => {\n    this.length = buffer.length;\n    this.encodeBytes = buffer.length;\n    this.decodeBytes = buffer.length;\n    if (!end) end = buffer.length;\n    this.length = buffer.length - offset;\n    if (offset + this.length > end) throw new RangeError(\"not enough data for decode\");\n    return Buffer.from(buffer.slice(offset, offset + this.length));\n  };\n}\n","import * as util from \"../util\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { checkDefined, checkLength } from \"../errors\";\n\nexport class CArray implements IBitcodec<any[]> {\n  private codecName = \"CArray\";\n  private length: number;\n  private anyCodec: IBitcodec<any>;\n\n  private calcLength = (items: any[]) => {\n    return util.calcAllLength(items, this.anyCodec.encodingLength);\n  };\n\n  encodingLength = (array?: any[]): number => {\n    checkDefined(this.codecName, array, \"array\");\n    if (array === undefined) return 0; // never\n    checkLength(this.codecName, array.length, this.length);\n    return this.calcLength(array);\n  };\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(length: number, anyCodec: IBitcodec<any>) {\n    this.length = length;\n    this.anyCodec = anyCodec;\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n  }\n\n  encode = (value: any[], buffer?: Buffer, offset = 0): Buffer => {\n    checkLength(this.codecName, value.length, this.length);\n\n    if (!buffer) buffer = Buffer.allocUnsafe(this.calcLength(value));\n    const typeEncode = this.anyCodec.encode;\n    const typeEncodeBytes = this.anyCodec.encodeBytes;\n\n    /* this.encodeBytes =\n      value.reduce((previusValue, currentItem, _) => {\n        this.anyCodec.encode(currentItem, buffer, previusValue);\n        const newAnyCodecEncodeBytes = this.anyCodec.encodeBytes;\n        return previusValue + newAnyCodecEncodeBytes;\n      }, offset) - offset; */\n\n    this.encodeBytes =\n      util.calcAllLength(\n        value,\n        function (item, index, loffset) {\n          typeEncode(item, buffer, loffset);\n          return typeEncodeBytes;\n        },\n        offset\n      ) - offset;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): any[] => {\n    if (!offset) offset = 0;\n    const items = new Array(this.length);\n\n    const typeDecode = this.anyCodec.decode;\n    const typeDecodeBytes = this.anyCodec.decodeBytes;\n\n    /* this.decodeBytes =\n      items.reduce((previusValue, currentItem, currentIndex) => {\n        items[currentIndex] = this.anyCodec.decode(buffer, previusValue, end);\n        const newAnyCodecDecodeBytes = this.anyCodec.decodeBytes;\n        return previusValue + newAnyCodecDecodeBytes;\n      }, offset + offset) - offset; */\n\n    this.decodeBytes =\n      util.calcAllLength(\n        items,\n        function (item, index, loffset) {\n          items[index || 0] = typeDecode(buffer, loffset, end);\n          return typeDecodeBytes;\n        },\n        offset\n      ) - offset;\n    return items;\n  };\n}\n","import { checkLength, checkBufferLengthForEncode, checkBufferLengthForDecode, checkDefined } from \"../errors\";\nimport { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CBuffer implements IBitcodec<Buffer> {\n  private codecName = \"Buffer\";\n  private length: number;\n  encodingLength = (): number => this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(length: number) {\n    this.length = length;\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n  }\n\n  encode = (value: Buffer, buffer?: Buffer, offset = 0): Buffer => {\n    checkDefined(this.codecName, value, \"buffer\");\n    checkLength(this.codecName, value.length, this.length);\n\n    if (!buffer) return Buffer.from(value);\n    checkBufferLengthForEncode(this.codecName, buffer, offset, this.length);\n\n    value.copy(buffer, offset);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): Buffer => {\n    if (!end) end = buffer.length;\n    checkBufferLengthForDecode(this.codecName, offset, end, this.length);\n\n    return Buffer.from(buffer.slice(offset, offset + this.length));\n  };\n}\n","import { Int53Type, readInt53, writeInt53 } from \"@bitmatrix/int53\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { NumberTypes } from \"../models/NumberTypes\";\n\nexport class CNumber implements IBitcodec<number> {\n  private length: number;\n  private write: (buffer: Buffer, value: number, offset?: number) => void;\n  private read: (buffer: Buffer, offset?: number | undefined) => number;\n\n  encodingLength = (number?: number): number => this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(numberType: NumberTypes, length: number) {\n    this.length = length;\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n\n    if (Buffer.prototype[\"write\" + numberType]) {\n      this.write = (buffer: Buffer, value: number, offset?: number) => {\n        return (buffer as any)[\"write\" + numberType](value, offset);\n      };\n    } else {\n      this.write = (buffer: Buffer, value: number, offset?: number) => {\n        return writeInt53(numberType as unknown as Int53Type, value, buffer, offset);\n      };\n    }\n\n    if (Buffer.prototype[\"read\" + numberType]) {\n      this.read = (buffer: Buffer, offset?: number) => {\n        return (buffer as any)[\"read\" + numberType](offset);\n      };\n    } else {\n      this.read = (buffer: Buffer, offset?: number) => {\n        return readInt53(numberType as unknown as Int53Type, buffer, offset);\n      };\n    }\n  }\n\n  encode = (value: number, buffer?: Buffer, offset = 0): Buffer => {\n    buffer = buffer || Buffer.allocUnsafe(this.length);\n    this.write(buffer, value, offset);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): number => {\n    if (!end) return this.read(buffer, offset);\n    return this.read(buffer.slice(offset, end), 0);\n  };\n}\n","import { checkBufferLengthForEncode, checkDefined } from \"../errors\";\nimport { BitcodecItem } from \"../models/BitcodecItem\";\nimport { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CObject implements IBitcodec<object> {\n  private codecName = \"CObject\";\n  private items: { name: string; type: IBitcodec<any> }[];\n\n  encodeBytes: number;\n  decodeBytes: number;\n  encodingLength: (t?: object) => number;\n\n  constructor(items: BitcodecItem[]) {\n    this.items = items.map((item: BitcodecItem) => (Array.isArray(item) ? { name: item[0], type: item[1] } : item));\n\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n\n    this.encodingLength = (o?: object): number => {\n      checkDefined(this.codecName, o, \"object\");\n      if (o === undefined) return 0; // never\n\n      return this.items.reduce((previousValue: number, currentValue: { name: string; type: IBitcodec<any> }) => {\n        const value = (o as any)[currentValue.name];\n        return previousValue + currentValue.type.encodingLength(value);\n      }, 0);\n    };\n  }\n\n  encode = (object: object, buffer?: Buffer, offset = 0): Buffer => {\n    const start = offset;\n    const bytes = this.encodingLength(object);\n    if (buffer === undefined) buffer = Buffer.allocUnsafe(bytes);\n    else checkBufferLengthForEncode(this.codecName, buffer, offset, bytes);\n\n    this.items.forEach((item) => {\n      const value = (object as any)[item.name];\n      item.type.encode(value, buffer, offset);\n      offset += item.type.encodeBytes;\n    });\n    this.encodeBytes = offset - start;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset: number = 0, end?: number | undefined): object => {\n    let result = {};\n    const start = offset;\n\n    this.items.forEach((item) => {\n      const value = item.type.decode(buffer, offset, end);\n      offset += item.type.decodeBytes;\n      (result as any)[item.name] = value;\n    });\n    this.decodeBytes = offset - start;\n\n    return result;\n  };\n}\n","import { checkBufferLengthForDecode, checkBufferLengthForEncode, checkLength } from \"../errors\";\nimport { EncodingType } from \"../models/EncodingType\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CBuffer } from \"./CBuffer\";\n\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_string\nexport class CString implements IBitcodec<string> {\n  private codecName = \"String\";\n  private length: number;\n  private bufferCodec: IBitcodec<Buffer>;\n  private encodingType: EncodingType;\n\n  encodingLength = (value?: string) => this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(length: number, encodingType: EncodingType = \"utf8\") {\n    this.length = length;\n    this.encodingType = encodingType;\n    this.bufferCodec = new CBuffer(this.length);\n\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n  }\n\n  encode = (value: string, buffer?: Buffer, offset = 0): Buffer => {\n    checkLength(this.codecName, Buffer.byteLength(value, this.encodingType), this.length);\n\n    if (!buffer) return Buffer.from(value, this.encodingType);\n    checkBufferLengthForEncode(this.codecName, buffer, offset, this.length);\n\n    buffer.write(value, offset, length, this.encodingType);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): string => {\n    checkBufferLengthForDecode(this.codecName, offset, end || buffer.length, this.length);\n    return this.bufferCodec.decode(buffer, offset, end).toString(this.encodingType);\n  };\n}\n","import * as util from \"../util\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { checkDefined } from \"../errors\";\n\nexport class CVarArray implements IBitcodec<any[]> {\n  private codecName = \"CVarArray\";\n  private length: number = -1;\n  private lengthCodec: IBitcodec<any>;\n  private itemCodec: IBitcodec<any>;\n\n  private calcLength = (items: any[]) => {\n    return util.calcAllLength(items, this.itemCodec.encodingLength, this.lengthCodec.encodingLength(items.length));\n  };\n\n  encodingLength = (array?: any[]): number => {\n    checkDefined(this.codecName, array, \"array\");\n    if (array === undefined) return 0; // never\n    return this.calcLength(array);\n  };\n\n  encodeBytes: number = -1;\n  decodeBytes: number = -1;\n\n  constructor(lengthCodec: IBitcodec<any>, itemCodec: IBitcodec<any>) {\n    this.lengthCodec = lengthCodec;\n    this.itemCodec = itemCodec;\n  }\n\n  encode = (value: any[], buffer?: Buffer, offset = 0): Buffer => {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.calcLength(value));\n\n    this.lengthCodec.encode(value.length, buffer, offset);\n\n    /* this.encodeBytes =\n      value.reduce((previusValue, currentItem, _) => {\n        this.anyCodec.encode(currentItem, buffer, previusValue);\n        const newAnyCodecEncodeBytes = this.anyCodec.encodeBytes;\n        return previusValue + newAnyCodecEncodeBytes;\n      }, this.lengthType.encodeBytes + offset) - offset; */\n\n    this.encodeBytes =\n      util.calcAllLength(\n        value,\n        (item, index, loffset) => {\n          this.itemCodec.encode(item, buffer, loffset);\n          return this.itemCodec.encodeBytes;\n        },\n        this.lengthCodec.encodeBytes + offset\n      ) - offset;\n\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): any[] => {\n    if (!offset) offset = 0;\n    const items = new Array(this.lengthCodec.decode(buffer, offset, end));\n\n    /* this.decodeBytes =\n      items.reduce((previusValue, currentItem, currentIndex) => {\n        items[currentIndex] = this.anyCodec.decode(buffer, previusValue, end);\n        const newAnyCodecDecodeBytes = this.anyCodec.decodeBytes;\n        return previusValue + newAnyCodecDecodeBytes;\n      }, this.lengthType.decodeBytes + offset) - offset; */\n\n    this.decodeBytes =\n      util.calcAllLength(\n        items,\n        (item, index, loffset) => {\n          items[index || 0] = this.itemCodec.decode(buffer, loffset, end);\n          return this.itemCodec.decodeBytes;\n        },\n        this.lengthCodec.decodeBytes + offset\n      ) - offset;\n    return items;\n  };\n}\n","import { checkBufferLengthForDecode, checkBufferLengthForEncode, checkDefined } from \"../errors\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CNumber } from \"./CNumber\";\nimport { CVarUIntBitcoin } from \"./CVarUIntBitcoin\";\n\nexport class CVarBuffer implements IBitcodec<any> {\n  private codecName = \"VarBuffer\";\n  private anyCodec: IBitcodec<any>;\n  encodingLength: (buffer?: Buffer) => number;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(anyCodec: IBitcodec<CNumber | CVarUIntBitcoin>) {\n    this.anyCodec = anyCodec;\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n\n    this.encodingLength = (buffer?: Buffer) => {\n      checkDefined(this.codecName, buffer, \"buffer\"); // for CArray encode iter\n      if (buffer !== undefined) return this.anyCodec.encodingLength(buffer.length) + buffer.length;\n      return 0; // never\n    };\n  }\n\n  encode = (value: Buffer, buffer?: Buffer, offset = 0): Buffer => {\n    const bytes = this.encodingLength(value);\n    if (!buffer) buffer = Buffer.allocUnsafe(bytes);\n    else checkBufferLengthForEncode(this.codecName, buffer, offset, bytes);\n\n    this.anyCodec.encode(value.length, buffer, offset);\n    offset += this.anyCodec.encodeBytes;\n\n    value.copy(buffer, offset);\n    this.encodeBytes = bytes;\n\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): Buffer => {\n    if (end === undefined) end = buffer.length;\n    const start = offset;\n    const length = this.anyCodec.decode(buffer, offset, end);\n    offset += this.anyCodec.decodeBytes;\n    checkBufferLengthForDecode(this.codecName, offset, end, length);\n\n    this.decodeBytes = offset + length - start;\n    return Buffer.from(buffer.slice(offset, offset + length));\n  };\n}\n","import { checkDefined } from \"../errors\";\nimport { EncodingType } from \"../models/EncodingType\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CVarBuffer } from \"./CVarBuffer\";\n\nexport class CVarString implements IBitcodec<string> {\n  private codecName = \"CVarString\";\n  private anyCodec: IBitcodec<any>;\n  private encodingType: EncodingType;\n  private varBufferCodec: CVarBuffer;\n  encodingLength: (value?: string) => number;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(anyCodec: IBitcodec<any>, encodingType: EncodingType = \"utf8\") {\n    this.anyCodec = anyCodec;\n    this.encodingType = encodingType;\n    this.varBufferCodec = new CVarBuffer(anyCodec);\n\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n\n    this.encodingLength = (value?: string) => {\n      checkDefined(this.codecName, value, \"string\");\n      if (value === undefined) return 0; // never;\n\n      const valueLength = Buffer.byteLength(value, this.encodingType);\n      return this.anyCodec.encodingLength(value.length) + valueLength;\n    };\n  }\n\n  encode = (value: string, buffer?: Buffer, offset = 0): Buffer => {\n    const valueLength = Buffer.byteLength(value, this.encodingType);\n    const bytes = this.anyCodec.encodingLength(value.length) + valueLength;\n\n    if (!buffer) buffer = Buffer.allocUnsafe(bytes);\n    if (offset + bytes > buffer.length) throw new RangeError(\"destination buffer is too small\");\n\n    this.anyCodec.encode(valueLength, buffer, offset);\n    offset += this.anyCodec.encodeBytes;\n    buffer.write(value, offset, valueLength, this.encodingType);\n\n    this.encodeBytes = bytes;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): string => {\n    const str = this.varBufferCodec.decode(buffer, offset, end).toString(this.encodingType);\n    this.decodeBytes = this.varBufferCodec.decodeBytes;\n    return str;\n  };\n}\n","import { checkDefined, rangeError, typeError } from \"../errors\";\nimport { IBitcodec } from \"../models/IBitcodec\";\n\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nexport class CVarUIntBitcoin implements IBitcodec<number> {\n  private codecName = \"VarUIntBitcoin\";\n  private MAX_SAFE_INTEGER: number = 9007199254740991;\n\n  private checkUInt53 = (n: number) => {\n    if (n < 0 || n > this.MAX_SAFE_INTEGER) rangeError(this.codecName, `out of range value. min = 0, max = ${this.MAX_SAFE_INTEGER}, value = ${n}`);\n    if (n % 1 !== 0) typeError(this.codecName, `value is not an integer. value = ${n}`);\n  };\n\n  encodeBytes: number;\n  decodeBytes: number;\n  encodingLength: (number?: number) => number;\n\n  constructor() {\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n    this.encodingLength = (number?: number) => {\n      checkDefined(this.codecName, number, \"number\");\n      if (number === undefined) return 0; // never\n\n      this.checkUInt53(number);\n      return number < 0xfd ? 1 : number <= 0xffff ? 3 : number <= 0xffffffff ? 5 : 9;\n    };\n  }\n\n  encode = (value: number, buffer?: Buffer, offset: number = 0): Buffer => {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.encodingLength(value));\n\n    // 8 bit\n    if (value < 0xfd) {\n      buffer.writeUInt8(value, offset);\n      this.encodeBytes = 1;\n\n      // 16 bit\n    } else if (value <= 0xffff) {\n      buffer.writeUInt8(0xfd, offset);\n      buffer.writeUInt16LE(value, offset + 1);\n      this.encodeBytes = 3;\n\n      // 32 bit\n    } else if (value <= 0xffffffff) {\n      buffer.writeUInt8(0xfe, offset);\n      buffer.writeUInt32LE(value, offset + 1);\n      this.encodeBytes = 5;\n\n      // 64 bit\n    } else {\n      buffer.writeUInt8(0xff, offset);\n      buffer.writeUInt32LE(value >>> 0, offset + 1);\n      buffer.writeUInt32LE((value / 0x100000000) | 0, offset + 5);\n      this.encodeBytes = 9;\n    }\n\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset: number = 0, end?: number): number => {\n    const first = buffer.readUInt8(offset);\n\n    // 8 bit\n    if (first < 0xfd) {\n      this.decodeBytes = 1;\n      return first;\n\n      // 16 bit\n    } else if (first === 0xfd) {\n      this.decodeBytes = 3;\n      return buffer.readUInt16LE(offset + 1);\n\n      // 32 bit\n    } else if (first === 0xfe) {\n      this.decodeBytes = 5;\n      return buffer.readUInt32LE(offset + 1);\n\n      // 64 bit\n    } else {\n      this.decodeBytes = 9;\n      var lo = buffer.readUInt32LE(offset + 1);\n      var hi = buffer.readUInt32LE(offset + 5);\n      var number = hi * 0x0100000000 + lo;\n      this.checkUInt53(number);\n\n      return number;\n    }\n  };\n}\n","export { CAllBuffer } from \"./CAllBuffer\";\nexport { CArray } from \"./CArray\";\nexport { CBuffer } from \"./CBuffer\";\nexport { CNumber } from \"./CNumber\";\nexport { CObject } from \"./CObject\";\nexport { CString } from \"./CString\";\nexport { CVarArray } from \"./CVarArray\";\nexport { CVarBuffer } from \"./CVarBuffer\";\nexport { CVarString } from \"./CVarString\";\nexport { CVarUIntBitcoin } from \"./CVarUIntBitcoin\";\n","export enum NumberTypes {\n  Byte = \"UInt8\",\n  Int8 = \"Int8\",\n  UInt8 = \"UInt8\",\n  Int16BE = \"Int16BE\",\n  Int16LE = \"Int16LE\",\n  UInt16BE = \"UInt16BE\",\n  UInt16LE = \"UInt16LE\",\n  Int32BE = \"Int32BE\",\n  Int32LE = \"Int32LE\",\n  UInt32BE = \"UInt32BE\",\n  UInt32LE = \"UInt32LE\",\n  Int64BE = \"Int64BE\",\n  Int64LE = \"Int64LE\",\n  UInt64BE = \"UInt64BE\",\n  UInt64LE = \"UInt64LE\",\n  FloatBE = \"FloatBE\",\n  FloatLE = \"FloatLE\",\n  DoubleBE = \"DoubleBE\",\n  DoubleLE = \"DoubleLE\",\n}\n","export { BitcodecItem } from \"./BitcodecItem\";\nexport { EncodingType } from \"./EncodingType\";\nexport { IBitcodec } from \"./IBitcodec\";\nexport { NumberTypes } from \"./NumberTypes\";\n","export const calcAllLength = <T>(items: T[], calcLength: (item?: T, itemIndex?: number, itemOffset?: number) => number, allOffset: number = 0) => {\n  let lOffset = allOffset;\n  for (let i = 0; i < items.length; i++) lOffset += calcLength(items[i], i, lOffset);\n  return lOffset;\n\n  /* return items.reduce((previusValue, currentItem, currentIndex) => {\n    return previusValue + iter(items[currentIndex], currentIndex, previusValue);\n  }, acc); */\n};\n\nconst copy = (obj: any): any => {\n  if (Buffer.isBuffer(obj)) return obj.slice();\n  if (Array.isArray(obj)) return obj.map(copy);\n  if (typeof obj === \"object\") {\n    const newObj: any = {};\n    for (let k in obj) {\n      newObj[k] = obj.map(copy);\n    }\n    return newObj;\n  }\n\n  if (typeof obj === \"function\") throw \"unsupported copy!\";\n  return obj;\n};\n\nfunction isHex(s: string) {\n  return s.length % 2 === 0 && /^[0-9a-f]*$/.test(s.toLowerCase());\n}\n\nexport function hex2buffer(obj: any) {\n  if (Buffer.isBuffer(obj)) return copy(obj);\n  else if (typeof obj === \"string\" && isHex(obj)) return Buffer.from(obj, \"hex\");\n  else if (typeof obj === \"object\") {\n    const newObj = copy(obj);\n    for (var k in newObj) {\n      newObj[k] = hex2buffer(newObj[k]);\n    }\n    return newObj;\n  } else if (Array.isArray(obj)) {\n    return copy(obj).map(hex2buffer);\n  }\n\n  return obj;\n}\n\nexport function buffer2hex(obj: any) {\n  if (Buffer.isBuffer(obj)) {\n    const newBuffer = copy(obj);\n    return newBuffer.toString(\"hex\");\n  } else if (Array.isArray(obj)) {\n    let newObj = copy(obj);\n    newObj = newObj.map(buffer2hex);\n    return newObj;\n  } else if (typeof obj === \"object\") {\n    const newObj = copy(obj);\n    for (var k in newObj) {\n      newObj[k] = buffer2hex(newObj[k]);\n    }\n    return newObj;\n  }\n\n  return obj;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { BitcodecItem, EncodingType, IBitcodec, NumberTypes } from \"./models\";\nimport { CAllBuffer, CArray, CBuffer, CNumber, CObject, CString, CVarArray, CVarBuffer, CVarString, CVarUIntBitcoin } from \"./lib\";\n\nconst bitcodec = {\n  AllBuffer: new CAllBuffer(),\n  Array: (length: number, anyCodec: IBitcodec<any>) => new CArray(length, anyCodec),\n  Buffer: (length: number) => new CBuffer(length),\n  Byte: new CNumber(NumberTypes.UInt8, 1),\n  Number: {\n    Int8: new CNumber(NumberTypes.Int8, 1),\n    UInt8: new CNumber(NumberTypes.UInt8, 1),\n    Int16BE: new CNumber(NumberTypes.Int16BE, 2),\n    Int16LE: new CNumber(NumberTypes.Int16LE, 2),\n    UInt16BE: new CNumber(NumberTypes.UInt16BE, 2),\n    UInt16LE: new CNumber(NumberTypes.UInt16LE, 2),\n    Int32BE: new CNumber(NumberTypes.Int32BE, 4),\n    Int32LE: new CNumber(NumberTypes.Int32LE, 4),\n    UInt32BE: new CNumber(NumberTypes.UInt32BE, 4),\n    UInt32LE: new CNumber(NumberTypes.UInt32LE, 4),\n    Int64BE: new CNumber(NumberTypes.Int64BE, 8),\n    Int64LE: new CNumber(NumberTypes.Int64LE, 8),\n    UInt64BE: new CNumber(NumberTypes.UInt64BE, 8),\n    UInt64LE: new CNumber(NumberTypes.UInt64LE, 8),\n    FloatBE: new CNumber(NumberTypes.FloatBE, 4),\n    FloatLE: new CNumber(NumberTypes.FloatLE, 4),\n    DoubleBE: new CNumber(NumberTypes.DoubleBE, 8),\n    DoubleLE: new CNumber(NumberTypes.DoubleLE, 8),\n  },\n  Object: (items: BitcodecItem[]) => new CObject(items),\n  String: (length: number, encodingType: EncodingType = \"utf8\") => new CString(length, encodingType),\n  VarArray: (lengthType: IBitcodec<any>, anyCodec: IBitcodec<any>) => new CVarArray(lengthType, anyCodec),\n  VarBuffer: (anyCodec: IBitcodec<any>) => new CVarBuffer(anyCodec),\n  VarString: (anyCodec: IBitcodec<any>, encodingType: EncodingType = \"utf8\") => new CVarString(anyCodec, encodingType),\n  VarUIntBitcoin: new CVarUIntBitcoin(),\n};\n\nexport default bitcodec;\nexport { IBitcodec };\nexport { hex2buffer, buffer2hex } from \"./util\";\n"],"names":["Object","defineProperty","exports","value","toDouble","intHighLow","uintHighLow","onesComplement","assert","Int53Type","MAX_UINT32","test","message","Error","number","Math","floor","high","signbit","low","hl","signed","readInt53","writeInt53","common_1","enumerable","get","write_1","write","read_1","read","int53Type","buffer","offset","BE","endsWith","readUInt32BE","readUInt32LE","startsWith","writeUInt32BE","writeUInt32LE","checkLength","codecName","valueLength","codecLength","RangeError","checkBufferLengthForEncode","length","checkBufferLengthForDecode","end","checkDefined","type","undefined","TypeError","Buffer","isBuffer","typeError","rangeError","encodingLength","this","encodeBytes","decodeBytes","constructor","encode","from","copy","decode","slice","anyCodec","calcLength","items","util","calcAllLength","array","allocUnsafe","typeEncode","typeEncodeBytes","item","index","loffset","Array","typeDecode","typeDecodeBytes","numberType","prototype","map","isArray","name","o","reduce","previousValue","currentValue","object","start","bytes","forEach","result","bufferCodec","encodingType","CBuffer","byteLength","toString","lengthCodec","itemCodec","varBufferCodec","CVarBuffer","str","MAX_SAFE_INTEGER","checkUInt53","n","writeUInt8","writeUInt16LE","first","readUInt8","readUInt16LE","lo","CAllBuffer","CArray","CNumber","CObject","CString","CVarArray","CVarString","CVarUIntBitcoin","NumberTypes","allOffset","lOffset","i","obj","newObj","k","hex2buffer","s","toLowerCase","buffer2hex","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","call","bitcodec","AllBuffer","Byte","UInt8","Number","Int8","Int16BE","Int16LE","UInt16BE","UInt16LE","Int32BE","Int32LE","UInt32BE","UInt32LE","Int64BE","Int64LE","UInt64BE","UInt64LE","FloatBE","FloatLE","DoubleBE","DoubleLE","String","VarArray","lengthType","VarBuffer","VarString","VarUIntBitcoin"],"sourceRoot":""}